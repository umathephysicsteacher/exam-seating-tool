# streamlit_exam_tool_download_all.py
# streamlit_exam_tool_download_all.py
# Streamlit app â€” final + "Download All Files to Downloads" feature
# Requirements: streamlit, pandas, reportlab
# Run: pip install streamlit pandas reportlab
# then: streamlit run streamlit_exam_tool_download_all.py

import streamlit as st
import pandas as pd
import io, os, math, random, datetime, re
from collections import defaultdict, deque
from pathlib import Path
from reportlab.lib.pagesizes import A4, landscape, portrait
from reportlab.lib import colors
from reportlab.lib.units import mm
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle

# ---------------- CONFIG ----------------
SEED_DEFAULT = 42
BUNDLE_SIZE_DEFAULT = 10
BASE_TIMESTAMP = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
PDF_FOOTER_TEMPLATE = "Generated by ExamSeatingTool v3 | {school} | {exam} | {ts}"

# ---------------- HELPERS ----------------
def yes(val):
    return str(val).strip().lower() == "yes"

def sanitize_filename(s):
    s = str(s or "")
    s = re.sub(r"[^\w\s-]", "", s).strip()
    s = re.sub(r"\s+", "_", s)
    return s

def make_student_code(row):
    grade = str(row.get('grade','')).strip()
    section = str(row.get('section','')).strip().upper() or "X"
    roll = str(row.get('roll','')).strip()
    gender = str(row.get('gender','')).strip().upper()
    ginit = gender[0] if gender else "X"
    return f"{grade}{section}{roll}{ginit}"

styles = getSampleStyleSheet()
title_style = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=16)
h2 = ParagraphStyle('h2', parent=styles['Heading2'], alignment=0, fontSize=12)
normal = styles['Normal']

# ---------------- PDF builders (same as before, compact) ----------------
def build_room_pdf_bytes(school, exam, room_id, assigns, summary_line, footer_text):
    buf = io.BytesIO()
    doc = SimpleDocTemplate(buf, pagesize=landscape(A4), rightMargin=18, leftMargin=18, topMargin=18, bottomMargin=24)
    elems=[]
    header = f"{school}\n{exam}\nEXAM SEATING ARRANGEMENT - ROOM {room_id}"
    elems.append(Paragraph(header, title_style))
    elems.append(Spacer(1,6))
    elems.append(Paragraph(summary_line, normal)); elems.append(Spacer(1,8))
    data=[("Col","Bench","Seat","Code","Name","Grade","Section","Paper Set")]
    for a in assigns:
        data.append((a['col'], a['bench'], a['seat_label'], a['student_code'], a['student_name'], a['grade'], a['section'], a['paper_set']))
    col_widths=[18*mm,18*mm,50*mm,35*mm,60*mm,20*mm,25*mm,25*mm]
    tbl = Table(data, colWidths=col_widths)
    tbl.setStyle(TableStyle([('GRID',(0,0),(-1,-1),0.4,colors.black),('BACKGROUND',(0,0),(-1,0),colors.lightgrey),
                             ('FONTNAME',(0,0),(-1,0),'Helvetica-Bold'),('ALIGN',(0,0),(-1,-1),'CENTER')]))
    elems.append(tbl); elems.append(Spacer(1,8))
    elems.append(Paragraph("Notes: Check student code. Use invigilator map for marking absentees.", normal)); elems.append(Spacer(1,12))
    elems.append(Paragraph(footer_text, ParagraphStyle('footer', alignment=1, fontSize=8)))
    doc.build(elems); buf.seek(0)
    return buf.read()

def build_invigilator_map_pdf_bytes(school, exam, room_id, seat_inventory, assigns, footer_text, preprint_rows_per_section=6):
    assign_by_seat = {a['seat_label']: a for a in assigns}
    max_bench = 0
    for s in seat_inventory:
        max_bench = max(max_bench, s.get('bench', 0))
    # headers C1-L,C1-R,...C3-R
    headers = tuple([f"C{c}-{pos}" for c in range(1,4) for pos in ("L","R")])
    data = [headers]
    for b in range(1, max_bench+1):
        row=[]
        for c in range(1,4):
            seats_here = [a for a in assigns if a['col']==c and a['bench']==b]
            left = seats_here[0] if len(seats_here)>=1 else None
            right = seats_here[1] if len(seats_here)>=2 else None
            def fmt(cell):
                if not cell: return " \n \n â€” \n â–¡"
                return f"{cell['student_code']}\n{cell['student_name'].split()[0] if cell.get('student_name') else ''}\n{cell['seat_label']}\nâ–¡"
            row.append(fmt(left)); row.append(fmt(right))
        data.append(tuple(row))
    # absentees templates per section
    sections = sorted({a['section'] for a in assigns if a.get('section')})
    buf = io.BytesIO()
    doc = SimpleDocTemplate(buf, pagesize=A4, rightMargin=18, leftMargin=18, topMargin=18, bottomMargin=24)
    elems=[]
    elems.append(Paragraph(f"{school}\n{exam}\nINVIGILATOR MAP - ROOM {room_id}", title_style)); elems.append(Spacer(1,6))
    elems.append(Paragraph(f"Room: {room_id} | Total seats: {len(seat_inventory)} | Assigned: {len(assigns)}", normal)); elems.append(Spacer(1,8))
    colw = [(A4[0]-36)/6]*6
    map_tbl = Table(data, colWidths=colw)
    map_tbl.setStyle(TableStyle([('GRID',(0,0),(-1,-1),0.3,colors.black),('BACKGROUND',(0,0),(-1,0),colors.lightgrey),
                                 ('FONTNAME',(0,0),(-1,0),'Helvetica-Bold'),('FONTSIZE',(0,0),(-1,-1),8)]))
    elems.append(map_tbl); elems.append(Spacer(1,12))
    elems.append(Paragraph("SECTION-WISE ABSENTEE LOG (write bench/seat & sign)", h2)); elems.append(Spacer(1,6))
    for sec in sections:
        elems.append(Paragraph(f"Section {sec}", ParagraphStyle('sec', fontSize=10)))
        rows=[("Bench/Seat","Code","Name","Reason","Invigilator Sign")]
        for _ in range(preprint_rows_per_section):
            rows.append(("","","","",""))
        tbl = Table(rows, colWidths=[30*mm,35*mm,60*mm,60*mm,40*mm])
        tbl.setStyle(TableStyle([('GRID',(0,0),(-1,-1),0.3,colors.black),('BACKGROUND',(0,0),(-1,0),colors.lightgrey),('FONTSIZE',(0,0),(-1,-1),9)]))
        elems.append(tbl); elems.append(Spacer(1,8))
    elems.append(Paragraph("Total Present: ______   Total Absent: ______", normal)); elems.append(Spacer(1,6))
    elems.append(Paragraph("I certify that the attendance recorded above is accurate. Invigilator Signature: ____________________", normal)); elems.append(Spacer(1,12))
    elems.append(Paragraph(footer_text, ParagraphStyle('footer', alignment=1, fontSize=8)))
    doc.build(elems); buf.seek(0)
    return buf.read()

# ---------------- Core assignment (same algorithm as before, returns outputs/pdfs dicts) --------------
def assign_seats_and_generate(files, school, exam, seed, bundle_size, preprint_rows_per_section=6):
    random.seed(seed)
    students = pd.read_csv(files['students'], dtype=str).fillna("")
    rooms = pd.read_csv(files['rooms'], dtype=str).fillna("")
    invigs = pd.read_csv(files['invigilators'], dtype=str).fillna("")
    for c in ["column1_benches","column2_benches","column3_benches"]:
        if c not in rooms.columns: rooms[c]=0
        rooms[c] = rooms[c].apply(lambda x: int(x) if str(x).strip()!="" else 0)
    rooms = rooms[rooms.get('available','Yes').apply(yes)].copy()
    seat_inv_by_room={}
    for _, r in rooms.iterrows():
        rid=r['room_id']; cols=[int(r.get(f'column{i}_benches',0) or 0) for i in range(1,4)]
        seats=[]
        for cidx, benches in enumerate(cols, start=1):
            for b in range(1, benches+1):
                seats.append({'room':rid,'col':cidx,'bench':b,'seat_label':f"{rid}-C{cidx}-B{b}"})
        seat_inv_by_room[rid]=seats
    students['allowed_rooms'] = students.get('allowed_rooms','').apply(lambda s: [x.strip() for x in str(s).split(",") if x.strip()])
    students['excluded_rooms'] = students.get('excluded_rooms','').apply(lambda s: [x.strip() for x in str(s).split(",") if x.strip()])
    students['grade']=students.get('grade','').astype(str).str.strip()
    students['paper_set']=students.get('paper_set','').astype(str).str.strip()
    students['section']=students.get('section','').astype(str).str.strip().str.upper()
    students['gender']=students.get('gender','').astype(str).str.strip().str.upper()
    students['student_code']=students.apply(make_student_code, axis=1)
    warnings=[]
    dup=students['student_code'][students['student_code'].duplicated(keep=False)]
    if not dup.empty:
        for c in dup.unique(): warnings.append(f"Duplicate student_code: {c}")
    assignments=[]; unseated=[]
    students_allowed = students[students['allowed_rooms'].apply(len)>0].copy()
    students_free = students[students['allowed_rooms'].apply(len)==0].copy()
    def rr_order(df):
        groups=defaultdict(list)
        for _, r in df.iterrows(): groups[str(r.get('grade','')).strip()].append(r)
        for g in groups: random.shuffle(groups[g])
        dq=[deque(groups[g]) for g in groups]; out=[]
        while any(dq):
            for d in dq:
                if d: out.append(d.popleft())
        return out
    free_order = rr_order(students_free)
    def find_seat_for_student(s):
        allowed = s.get('allowed_rooms', []); excluded = s.get('excluded_rooms', []); grade=str(s.get('grade','')).strip()
        rooms_to_check = allowed if allowed else [rid for rid in seat_inv_by_room.keys() if rid not in excluded]
        for rid in rooms_to_check:
            if rid not in seat_inv_by_room: continue
            rentry = rooms[rooms['room_id']==rid]; allowed_set=set()
            if not rentry.empty and 'grade_allowed' in rooms.columns:
                gs = str(rentry.iloc[0].get('grade_allowed','')).strip()
                if gs: allowed_set = set([x.strip() for x in gs.split("|") if x.strip()])
            if allowed_set and grade and grade not in allowed_set: continue
            # benches occupancy counts
            benches = defaultdict(int)
            for a in assignments:
                if a['room']==rid: benches[(a['col'], a['bench'])]+=1
            # find first bench with count <2
            target=None
            for seat in seat_inv_by_room[rid]:
                if benches[(seat['col'], seat['bench'])] < 2:
                    target = seat; break
            if target:
                assignments.append({'seat_label': target['seat_label'], 'room': target['room'], 'col': target['col'], 'bench': target['bench'],
                                    'student_code': s['student_code'], 'student_name': s.get('student_name',''), 'grade': s['grade'], 'section': s['section'], 'paper_set': s['paper_set'], 'roll': s.get('roll','')})
                return True
        return False
    for _, s in students_allowed.iterrows():
        if not find_seat_for_student(s):
            warnings.append(f"No seat for allowed-room student: {s['student_code']}"); unseated.append(s.to_dict())
    for s in free_order:
        if not find_seat_for_student(s):
            warnings.append(f"No seat for student: {s['student_code']}"); unseated.append(s.to_dict())
    # capacity checks
    for rid, seats in seat_inv_by_room.items():
        seated_count = len([a for a in assignments if a['room']==rid]); capacity = len(seats)*2
        if seated_count > capacity: warnings.append(f"Room {rid} over capacity: {seated_count} > {capacity}")
    outputs={}
    df_assign = pd.DataFrame(assignments)
    prefix = f"{sanitize_filename(school)}_{sanitize_filename(exam)}_{BASE_TIMESTAMP}"
    outputs[f"{prefix}_seat_assignments.csv"] = df_assign.sort_values(['room','col','bench']).to_csv(index=False).encode('utf-8')
    outputs[f"{prefix}_warnings.txt"] = ("\n".join(warnings) if warnings else "No warnings.").encode('utf-8')
    if unseated: outputs[f"{prefix}_unseated_students.csv"] = pd.DataFrame(unseated).to_csv(index=False).encode('utf-8')
    # invigilators
    if 'availability' not in invigs.columns: invigs['availability']="Yes"
    if 'handles_class10' not in invigs.columns: invigs['handles_class10']="No"
    invigs_av = invigs[invigs['availability'].apply(yes)].copy()
    invig_list = invigs_av.to_dict('records'); invig_idx=0; invig_rows=[]
    room_assign_map = defaultdict(list)
    for a in assignments: room_assign_map[a['room']].append(a)
    for rid in room_assign_map.keys():
        room_assigns = room_assign_map[rid]; has10 = any(str(a.get('grade','')).strip()=="10" for a in room_assigns)
        chosen=None
        if has10:
            for inv in invig_list:
                if yes(inv.get('handles_class10','No')): chosen = inv; break
        if not chosen and invig_list:
            chosen = invig_list[invig_idx%len(invig_list)]; invig_idx+=1
        invig_rows.append({'room': rid, 'invigilator_id': chosen.get('invigilator_id','') if chosen else '', 'invigilator_name': chosen.get('name','') if chosen else '', 'has_class10': "Yes" if has10 else "No", 'num_students': len(room_assigns)})
    outputs[f"{prefix}_invigilation_list.csv"] = pd.DataFrame(invig_rows).to_csv(index=False).encode('utf-8')
    teacher_load=defaultdict(lambda:{'rooms':[],'students':0,'class10':'No'})
    for r in invig_rows:
        name = r['invigilator_name'] or "UNASSIGNED"; teacher_load[name]['rooms'].append(r['room']); teacher_load[name]['students']+=r['num_students']
        if r['has_class10']=="Yes': teacher_load[name]['class10']="Yes"
    trows=[] 
    for name,info in teacher_load.items(): trows.append({'invigilator_name':name,'rooms':",".join(info['rooms']),'total_students':info['students'],'class10_present':info['class10']})
    outputs[f"{prefix}_teacher_load_report.csv"] = pd.DataFrame(trows).to_csv(index=False).encode('utf-8')
    # bundles
    bundle_rows=[]
    if not df_assign.empty:
        for (room,grade), g in df_assign.groupby(['room','grade']):
            student_count=len(g); distinct_sets=len(g['paper_set'].unique()); bundles_needed=math.ceil(student_count / bundle_size) if student_count>0 else 0
            invigilator_name = next((row['invigilator_name'] for row in invig_rows if row['room']==room), '')
            bundle_rows.append({'room':room,'grade':grade,'student_count':student_count,'distinct_sets':distinct_sets,'bundles_needed':bundles_needed,'invigilator':invigilator_name})
    outputs[f"{prefix}_paper_bundles.csv"] = pd.DataFrame(bundle_rows).to_csv(index=False).encode('utf-8')
    # absentee templates per room
    for rid, assigns in room_assign_map.items():
        rows=[]
        for a in assigns:
            rows.append({'room':rid,'section':a['section'],'bench':a['bench'],'seat_label':a['seat_label'],'student_code':a['student_code'],'student_name':a['student_name'],'reason':'','invigilator':'','invigilator_sign':'','recorded_at':''})
        for _ in range(preprint_rows_per_section):
            rows.append({'room':rid,'section':'','bench':'','seat_label':'','student_code':'','student_name':'','reason':'','invigilator':'','invigilator_sign':'','recorded_at':''})
        key=f"{prefix}_absentees_template_{rid}.csv"
        outputs[key] = pd.DataFrame(rows).to_csv(index=False).encode('utf-8')
    # PDFs
    pdfs={}
    footer_text = PDF_FOOTER_TEMPLATE.format(school=school, exam=exam, ts=BASE_TIMESTAMP)
    for rid, assigns in room_assign_map.items():
        summary_line = f"Room: {rid}  |  Grades: {', '.join(sorted(set([str(a['grade']) for a in assigns])))}  |  Total assigned: {len(assigns)}"
        pdfs[f"{prefix}_{rid}_Seat_Assignment.pdf"] = build_room_pdf_bytes(school, exam, rid, sorted(assigns, key=lambda x:(x['col'], x['bench'])), summary_line, footer_text)
        seat_list = seat_inv_by_room.get(rid, [])
        pdfs[f"{prefix}_{rid}_Invigilator_Map.pdf"] = build_invigilator_map_pdf_bytes(school, exam, rid, seat_list, sorted(assigns, key=lambda x:(x['col'], x['bench'])), footer_text, preprint_rows_per_section)
    # paper bundle labels PDF
    if bundle_rows:
        buf = io.BytesIO(); doc = SimpleDocTemplate(buf, pagesize=portrait(A4), rightMargin=12, leftMargin=12, topMargin=12, bottomMargin=12)
        elems=[Paragraph(f"{school} | {exam} | PAPER BUNDLE LABELS", title_style), Spacer(1,6)]
        for br in bundle_rows:
            elems.append(Paragraph(f"Room: {br['room']} | Grade: {br['grade']} | Bundles: {br['bundles_needed']} | Papers: {br['student_count']} | Invigilator: {br['invigilator']}", normal)); elems.append(Spacer(1,4))
        elems.append(Spacer(1,12)); elems.append(Paragraph(footer_text, ParagraphStyle('footer', alignment=1, fontSize=8))); doc.build(elems); buf.seek(0)
        pdfs[f"{prefix}_paper_bundle_labels.pdf"] = buf.read()
    return outputs, pdfs

# ---------------- UI ----------------
st.set_page_config(page_title="ExamSeatingTool â€” Download All", layout="wide")
st.title("Exam Seating Tool â€” Download All (one-click save to Downloads)")

with st.sidebar:
    st.header("Run configuration")
    school = st.text_input("School name", value="Tadepalligudem High School")
    exam = st.text_input("Exam name", value="SA-1")
    seed = st.number_input("Random seed", value=SEED_DEFAULT, step=1)
    bundle_size = st.number_input("Bundle size (papers per bundle)", value=BUNDLE_SIZE_DEFAULT, step=1)
    preprint_rows = st.number_input("Preprint absentee rows per section", value=6, min_value=1, max_value=20, step=1)

st.subheader("Actions")
action = st.radio("", options=["Generate templates", "Run seating"])

if action == "Generate templates":
    if st.button("Create & download templates"):
        students = pd.DataFrame([{"roll":"301","student_name":"Ram Kumar","grade":"7","section":"C","gender":"M","allowed_rooms":"","excluded_rooms":"","needs":"","paper_set":"A"}])
        rooms = pd.DataFrame([{"room_id":"Room101","grade_allowed":"6|7|8|10","available":"Yes","column1_benches":8,"column2_benches":8,"column3_benches":8}])
        invigs = pd.DataFrame([{"invigilator_id":"I01","name":"Ms. Rao","handles_class10":"Yes","availability":"Yes"}])
        buf=io.StringIO(); students.to_csv(buf,index=False); st.download_button("Download students_template.csv", buf.getvalue().encode('utf-8'), file_name="students_template.csv")
        buf=io.StringIO(); rooms.to_csv(buf,index=False); st.download_button("Download rooms_template.csv", buf.getvalue().encode('utf-8'), file_name="rooms_template.csv")
        buf=io.StringIO(); invigs.to_csv(buf,index=False); st.download_button("Download invigilators_template.csv", buf.getvalue().encode('utf-8'), file_name="invigilators_template.csv")
        st.success("Templates ready.")

elif action == "Run seating":
    students_file = st.file_uploader("students.csv", type=["csv"])
    rooms_file = st.file_uploader("rooms.csv", type=["csv"])
    invigs_file = st.file_uploader("invigilators.csv", type=["csv"])
    if st.button("Run seating engine"):
        if not (students_file and rooms_file and invigs_file):
            st.error("Please upload all three CSV files.")
        else:
            with st.spinner("Generating..."):
                files = {'students': students_file, 'rooms': rooms_file, 'invigilators': invigs_file}
                outputs, pdfs = assign_seats_and_generate(files, school, exam, seed, bundle_size, preprint_rows_per_section=preprint_rows)
                # save to session_state for later one-click download
                st.session_state['outputs'] = outputs
                st.session_state['pdfs'] = pdfs
            st.success("Generation complete. Use individual downloads or 'Download All'.")

# Show individual downloads if present
if 'outputs' in st.session_state:
    st.subheader("CSV outputs (individual)")
    for name, b in st.session_state['outputs'].items():
        st.download_button(label=f"Download {name}", data=b, file_name=name)
if 'pdfs' in st.session_state:
    st.subheader("PDF outputs (individual)")
    for name, b in st.session_state['pdfs'].items():
        st.download_button(label=f"Download {name}", data=b, file_name=name)

# ---------------- One-click download to Downloads folder ----------------
def save_all_to_downloads(outputs: dict, pdfs: dict, school: str, exam: str, ts: str):
    downloads = Path.home() / "Downloads"
    folder_name = f"ExamSeating_{sanitize_filename(school)}_{sanitize_filename(exam)}_{ts}"
    base_dir = downloads / folder_name
    csv_dir = base_dir / "CSVs"
    pdf_dir = base_dir / "PDFs"
    csv_dir.mkdir(parents=True, exist_ok=True)
    pdf_dir.mkdir(parents=True, exist_ok=True)
    # write CSVs/TXTs
    for fname, blob in outputs.items():
        path = csv_dir / fname
        with open(path, "wb") as f:
            f.write(blob)
    # write PDFs
    for fname, blob in pdfs.items():
        path = pdf_dir / fname
        with open(path, "wb") as f:
            f.write(blob)
    return base_dir

if st.session_state.get('outputs') and st.session_state.get('pdfs'):
    st.markdown("---")
    st.subheader("One-click: save every file into your Downloads folder")
    if st.button("ðŸ“¥ Download All Files to Downloads"):
        with st.spinner("Saving files to your Downloads folder..."):
            try:
                out_dir = save_all_to_downloads(st.session_state['outputs'], st.session_state['pdfs'], school, exam, BASE_TIMESTAMP)
                st.success(f"All files saved to: {out_dir}")
                # Try to open Explorer (Windows)
                try:
                    if os.name == 'nt':
                        os.startfile(out_dir)  # Windows only
                    else:
                        st.info(f"Open the folder manually: {out_dir}")
                except Exception:
                    st.info(f"Open the folder manually: {out_dir}")
            except Exception as e:
                st.error(f"Failed to save files: {e}")

st.markdown("---")
st.caption("One-click saving writes separate CSV & PDF files to Downloads (no zip).")
